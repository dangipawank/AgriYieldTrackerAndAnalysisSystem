<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Yield Analysis</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>
  <body>
    <div class="container py-4">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <h1 class="mb-0">AgriData Analysis</h1>
        <a
          class="btn btn-outline-primary"
          href="{{ url_for('main.dashboard') }}"
          >Back to Dashboard</a
        >
      </div>

      {% with messages = get_flashed_messages(with_categories=true) %} {% if
      messages %} {% for category, message in messages %}
      <div class="alert alert-{{ category }}">{{ message }}</div>
      {% endfor %} {% endif %} {% endwith %}

      <div
        id="analysisStatus"
        class="alert alert-warning d-none"
        role="alert"
      ></div>

      <div class="row g-3 mb-4">
        <div class="col-md-6">
          <div class="card p-3">
            <label for="cropSelect" class="form-label">Trend Crop</label>
            <select id="cropSelect" class="form-select">
              <option value="">Choose crop</option>
              {% for crop in crops %}
              <option value="{{ crop.CropId }}">{{ crop.CropName }}</option>
              {% endfor %}
            </select>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card p-3">
            <label for="districtSelect" class="form-label"
              >Comparison District (optional)</label
            >
            <select id="districtSelect" class="form-select">
              <option value="">All districts</option>
              {% for d in districts %}
              <option value="{{ d.districtid }}">{{ d.districtname }}</option>
              {% endfor %}
            </select>
          </div>
        </div>
      </div>

      <div class="row g-3 mb-4">
        <div class="col-md-3">
          <div class="card p-3">
            <div class="text-muted small">Total Production</div>
            <div id="kpiTotalProduction" class="h5 mb-0">0.00</div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="card p-3">
            <div class="text-muted small">Total Area (ha)</div>
            <div id="kpiTotalArea" class="h5 mb-0">0.00</div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="card p-3">
            <div class="text-muted small">Average Yield/ha</div>
            <div id="kpiAvgYield" class="h5 mb-0">0.00</div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="card p-3">
            <div class="text-muted small">Top Crop</div>
            <div id="kpiTopCrop" class="h6 mb-0">N/A</div>
          </div>
        </div>
      </div>

      <div class="row g-4">
        <div class="col-lg-6">
          <div class="card p-3">
            <h5>Production Trend (Line)</h5>
            <canvas id="trendChart" height="160"></canvas>
          </div>
        </div>
        <div class="col-lg-6">
          <div class="card p-3">
            <h5>Crop Comparison (Bar)</h5>
            <canvas id="comparisonChart" height="160"></canvas>
          </div>
        </div>
      </div>

      <div class="row g-4 mt-2">
        <div class="col-lg-6">
          <div class="card p-3">
            <h5>Production Share by Crop (Pie)</h5>
            <canvas id="cropShareChart" height="180"></canvas>
            <div id="cropShareLegend" class="small mt-2 text-muted"></div>
          </div>
        </div>
        <div class="col-lg-6">
          <div class="card p-3">
            <h5>Production Share by District (Doughnut)</h5>
            <canvas id="districtShareChart" height="180"></canvas>
            <div id="districtShareLegend" class="small mt-2 text-muted"></div>
          </div>
        </div>
      </div>

      <div class="row g-4 mt-2">
        <div class="col-12">
          <div class="card p-3">
            <h5>Aggregate Summary (By Crop)</h5>
            <table>
              <thead>
                <tr>
                  <th>Crop</th>
                  <th>Total Production</th>
                  <th>Avg Yield/ha</th>
                  <th>Total Area</th>
                </tr>
              </thead>
              <tbody id="cropSummaryBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <script>
      function numberFmt(value) {
        return Number(value || 0).toFixed(2);
      }

      function showStatus(message) {
        const status = document.getElementById("analysisStatus");
        if (!message) {
          status.classList.add("d-none");
          status.innerText = "";
          return;
        }
        status.innerText = message;
        status.classList.remove("d-none");
      }

      async function apiGetJson(url, errorContext) {
        const response = await fetch(url);
        let payload = null;
        try {
          payload = await response.json();
        } catch {
          payload = null;
        }

        if (!response.ok) {
          const reason = payload?.error || `HTTP ${response.status}`;
          throw new Error(`${errorContext}: ${reason}`);
        }

        return payload || {};
      }

      function chartColors(count) {
        const palette = [
          "#0d6efd",
          "#198754",
          "#dc3545",
          "#fd7e14",
          "#6f42c1",
          "#20c997",
          "#0dcaf0",
          "#ffc107",
          "#6c757d",
          "#6610f2",
        ];
        return Array.from(
          { length: count },
          (_, i) => palette[i % palette.length],
        );
      }

      function districtNameMap() {
        const map = {};
        const options = document.getElementById("districtSelect").options;
        for (const opt of options) {
          if (opt.value) map[opt.value] = opt.text;
        }
        return map;
      }

      function setupCanvas(canvasId) {
        const canvas = document.getElementById(canvasId);
        const cssWidth = Math.max(canvas.clientWidth || 320, 320);
        const cssHeight = Number(canvas.getAttribute("height") || 180);
        const ratio = window.devicePixelRatio || 1;

        canvas.width = Math.floor(cssWidth * ratio);
        canvas.height = Math.floor(cssHeight * ratio);
        canvas.style.width = `${cssWidth}px`;
        canvas.style.height = `${cssHeight}px`;

        const ctx = canvas.getContext("2d");
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        ctx.clearRect(0, 0, cssWidth, cssHeight);

        return { ctx, width: cssWidth, height: cssHeight };
      }

      function drawNoData(ctx, width, height) {
        ctx.fillStyle = "#6c757d";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText("No data available", width / 2, height / 2);
      }

      function drawCartesianAxes(ctx, width, height, maxY) {
        const padding = { left: 46, right: 18, top: 16, bottom: 34 };
        const chartW = width - padding.left - padding.right;
        const chartH = height - padding.top - padding.bottom;

        ctx.strokeStyle = "#d0d7de";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top);
        ctx.lineTo(padding.left, padding.top + chartH);
        ctx.lineTo(padding.left + chartW, padding.top + chartH);
        ctx.stroke();

        const steps = 5;
        ctx.fillStyle = "#6c757d";
        ctx.font = "11px Arial";
        ctx.textAlign = "right";

        for (let i = 0; i <= steps; i += 1) {
          const yValue = (maxY / steps) * (steps - i);
          const y = padding.top + (chartH / steps) * i;

          ctx.strokeStyle = "#edf1f5";
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + chartW, y);
          ctx.stroke();

          ctx.fillText(numberFmt(yValue), padding.left - 6, y + 3);
        }

        return { padding, chartW, chartH };
      }

      function renderLegend(elementId, labels, values, colors) {
        const host = document.getElementById(elementId);
        const total = values.reduce(
          (sum, value) => sum + Number(value || 0),
          0,
        );

        if (!labels.length || total <= 0) {
          host.innerHTML = "";
          return;
        }

        host.innerHTML = labels
          .map((label, index) => {
            const value = Number(values[index] || 0);
            const pct = total > 0 ? ((value / total) * 100).toFixed(1) : "0.0";
            return `<div class=\"d-flex align-items-center gap-2 mb-1\"><span style=\"display:inline-block;width:10px;height:10px;border-radius:2px;background:${colors[index]};\"></span><span>${label}: ${numberFmt(value)} (${pct}%)</span></div>`;
          })
          .join("");
      }

      function renderTrendChart(labels, values) {
        const numericValues = values.map((value) => Number(value || 0));
        const { ctx, width, height } = setupCanvas("trendChart");

        if (!labels.length || !numericValues.length) {
          drawNoData(ctx, width, height);
          return;
        }

        const maxY = Math.max(...numericValues, 0) * 1.1 || 1;
        const { padding, chartW, chartH } = drawCartesianAxes(
          ctx,
          width,
          height,
          maxY,
        );
        const stepX =
          labels.length > 1 ? chartW / (labels.length - 1) : chartW / 2;

        ctx.beginPath();
        ctx.strokeStyle = "#0d6efd";
        ctx.lineWidth = 2;

        labels.forEach((label, index) => {
          const x =
            padding.left + (labels.length > 1 ? index * stepX : chartW / 2);
          const y =
            padding.top + chartH - (numericValues[index] / maxY) * chartH;
          if (index === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();

        ctx.fillStyle = "#0d6efd";
        labels.forEach((label, index) => {
          const x =
            padding.left + (labels.length > 1 ? index * stepX : chartW / 2);
          const y =
            padding.top + chartH - (numericValues[index] / maxY) * chartH;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.fillStyle = "#495057";
        ctx.font = "11px Arial";
        ctx.textAlign = "center";
        labels.forEach((label, index) => {
          const x =
            padding.left + (labels.length > 1 ? index * stepX : chartW / 2);
          ctx.fillText(String(label), x, height - 12);
        });
      }

      function renderComparisonChart(labels, values) {
        const numericValues = values.map((value) => Number(value || 0));
        const { ctx, width, height } = setupCanvas("comparisonChart");

        if (!labels.length || !numericValues.length) {
          drawNoData(ctx, width, height);
          return;
        }

        const maxY = Math.max(...numericValues, 0) * 1.1 || 1;
        const { padding, chartW, chartH } = drawCartesianAxes(
          ctx,
          width,
          height,
          maxY,
        );
        const barGap = 12;
        const barWidth = Math.max(
          Math.min((chartW - barGap * (labels.length - 1)) / labels.length, 36),
          8,
        );

        labels.forEach((label, index) => {
          const value = numericValues[index];
          const barHeight = (value / maxY) * chartH;
          const x = padding.left + index * (barWidth + barGap);
          const y = padding.top + chartH - barHeight;

          ctx.fillStyle = "rgba(25, 135, 84, 0.75)";
          ctx.fillRect(x, y, barWidth, barHeight);
          ctx.strokeStyle = "#198754";
          ctx.strokeRect(x, y, barWidth, barHeight);

          ctx.fillStyle = "#495057";
          ctx.font = "11px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            String(label).slice(0, 8),
            x + barWidth / 2,
            height - 12,
          );
        });
      }

      function renderCropShare(labels, values) {
        const numericValues = values.map((value) => Number(value || 0));
        const { ctx, width, height } = setupCanvas("cropShareChart");
        const total = numericValues.reduce((sum, value) => sum + value, 0);
        const colors = chartColors(labels.length);

        if (!labels.length || total <= 0) {
          drawNoData(ctx, width, height);
          renderLegend("cropShareLegend", [], [], []);
          return;
        }

        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.max(Math.min(width, height) / 2 - 20, 30);

        let startAngle = -Math.PI / 2;
        numericValues.forEach((value, index) => {
          const slice = (value / total) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, startAngle + slice);
          ctx.closePath();
          ctx.fillStyle = colors[index];
          ctx.fill();
          startAngle += slice;
        });

        renderLegend("cropShareLegend", labels, numericValues, colors);
      }

      function renderDistrictShare(labels, values) {
        const numericValues = values.map((value) => Number(value || 0));
        const { ctx, width, height } = setupCanvas("districtShareChart");
        const total = numericValues.reduce((sum, value) => sum + value, 0);
        const colors = chartColors(labels.length);

        if (!labels.length || total <= 0) {
          drawNoData(ctx, width, height);
          renderLegend("districtShareLegend", [], [], []);
          return;
        }

        const centerX = width / 2;
        const centerY = height / 2;
        const outerRadius = Math.max(Math.min(width, height) / 2 - 18, 30);
        const innerRadius = outerRadius * 0.55;

        let startAngle = -Math.PI / 2;
        numericValues.forEach((value, index) => {
          const slice = (value / total) * Math.PI * 2;
          ctx.beginPath();
          ctx.arc(
            centerX,
            centerY,
            outerRadius,
            startAngle,
            startAngle + slice,
          );
          ctx.arc(
            centerX,
            centerY,
            innerRadius,
            startAngle + slice,
            startAngle,
            true,
          );
          ctx.closePath();
          ctx.fillStyle = colors[index];
          ctx.fill();
          startAngle += slice;
        });

        renderLegend("districtShareLegend", labels, numericValues, colors);
      }

      async function loadComparison() {
        try {
          const data = await apiGetJson(
            "{{ url_for('analysis.crop_comparison') }}",
            "Unable to load crop comparison",
          );
          renderComparisonChart(data.crops || [], data.production || []);
          showStatus("");
        } catch (error) {
          renderComparisonChart([], []);
          showStatus(error.message);
        }
      }

      async function loadSummary() {
        try {
          const data = await apiGetJson(
            "{{ url_for('analysis.analysis_summary') }}",
            "Unable to load analysis summary",
          );
          const body = document.getElementById("cropSummaryBody");
          body.innerHTML = "";

          const byCrop = data.by_crop || [];
          const byDistrict = data.by_district || [];

          const totalProduction = byCrop.reduce(
            (sum, item) => sum + Number(item.total_production || 0),
            0,
          );
          const totalArea = byCrop.reduce(
            (sum, item) => sum + Number(item.total_area || 0),
            0,
          );

          let topCrop = "N/A";
          if (byCrop.length > 0) {
            const top = [...byCrop].sort(
              (a, b) =>
                Number(b.total_production || 0) -
                Number(a.total_production || 0),
            )[0];
            topCrop = `${top.crop} (${numberFmt(top.total_production)})`;
          }

          document.getElementById("kpiTotalProduction").innerText =
            numberFmt(totalProduction);
          document.getElementById("kpiTotalArea").innerText =
            numberFmt(totalArea);
          document.getElementById("kpiAvgYield").innerText =
            totalArea > 0 ? numberFmt(totalProduction / totalArea) : "0.00";
          document.getElementById("kpiTopCrop").innerText = topCrop;

          if (byCrop.length === 0) {
            const emptyRow = document.createElement("tr");
            emptyRow.innerHTML =
              '<td colspan="4" class="text-center text-muted">No data available</td>';
            body.appendChild(emptyRow);
          } else {
            byCrop.forEach((item) => {
              const row = document.createElement("tr");
              row.innerHTML = `
                <td>${item.crop}</td>
                <td>${Number(item.total_production).toFixed(2)}</td>
                <td>${Number(item.avg_yield_per_hectare).toFixed(2)}</td>
                <td>${Number(item.total_area).toFixed(2)}</td>
              `;
              body.appendChild(row);
            });
          }

          renderCropShare(
            byCrop.map((item) => item.crop),
            byCrop.map((item) => Number(item.total_production || 0)),
          );

          const districtMap = districtNameMap();
          renderDistrictShare(
            byDistrict.map(
              (item) =>
                districtMap[String(item.district_id)] ||
                `District ${item.district_id}`,
            ),
            byDistrict.map((item) => Number(item.total_production || 0)),
          );
          showStatus("");
        } catch (error) {
          showStatus(error.message);
        }
      }

      const trendBaseUrl =
        "{{ url_for('analysis.trend_analysis', crop_id=0) }}";
      const districtBaseUrl =
        "{{ url_for('analysis.district_analysis', district_id=0) }}";

      async function loadTrendByCrop(cropId) {
        if (!cropId) {
          renderTrendChart([], []);
          return;
        }
        try {
          const data = await apiGetJson(
            trendBaseUrl.replace(/0$/, String(cropId)),
            "Unable to load trend data",
          );
          renderTrendChart(data.years || [], data.production || []);
          showStatus("");
        } catch (error) {
          renderTrendChart([], []);
          showStatus(error.message);
        }
      }

      async function loadDistrictAnalysis(districtId) {
        if (!districtId) {
          await loadComparison();
          return;
        }

        try {
          const data = await apiGetJson(
            districtBaseUrl.replace(/0$/, String(districtId)),
            "Unable to load district analysis",
          );
          renderComparisonChart(data.crops || [], data.production || []);
          showStatus("");
        } catch (error) {
          renderComparisonChart([], []);
          showStatus(error.message);
        }
      }

      document
        .getElementById("cropSelect")
        .addEventListener("change", (event) => {
          loadTrendByCrop(event.target.value);
        });

      document
        .getElementById("districtSelect")
        .addEventListener("change", (event) => {
          loadDistrictAnalysis(event.target.value);
        });

      async function initializeAnalysisPage() {
        await loadComparison();
        await loadSummary();

        const cropSelect = document.getElementById("cropSelect");
        if (!cropSelect.value && cropSelect.options.length > 1) {
          cropSelect.value = cropSelect.options[1].value;
        }

        if (cropSelect.value) {
          await loadTrendByCrop(cropSelect.value);
        } else {
          renderTrendChart([], []);
        }
      }

      initializeAnalysisPage();
    </script>
  </body>
</html>
